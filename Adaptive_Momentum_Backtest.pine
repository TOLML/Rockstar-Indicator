// ═══════════════════════════════════════════════════════════════════════════════
// ADAPTIVE MOMENTUM v4.1 — HIERARCHICAL MULTI-LAYER SIGNAL SYSTEM
// PineScript: v6
// ═══════════════════════════════════════════════════════════════════════════════
//
// ARCHITECTURE:
//   3-layer hierarchical filter (NOT naive indicator voting).
//   Based on Faber (2007) trend-following and Jegadeesh-Titman (1993) momentum.
//
//   Layer 1 — TREND GATE: Price vs 200-day SMA. Must pass or system outputs
//             Distribute/Strong Sell regardless of other indicators.
//   Layer 2 — MOMENTUM CONFIRMATION: 12-month ROC positive AND RSI(14) > 50.
//   Layer 3 — CONVICTION SCORING: OBV slope, ATR volatility regime,
//             BB Squeeze detection. Composite score 0–10.
//
//   Output: 5 actionable zones mapped from composite score.
//     Strong Buy (8–10), Accumulate (6–8), Hold (4–6),
//     Distribute (2–4), Strong Sell (0–2).
//
//   Automatic ATR-normalized adaptation — no asset-type selector needed.
//   Single user control: 7-level sensitivity preset.
//
// v4.1 IMPROVEMENTS (research-validated, A/B tested on BTC + SPY):
//   Volatility-adaptive score smoothing (auto-scales with asset ATR%)
//   Zone hysteresis (asymmetric entry/exit thresholds at Sens 4+)
//   Result: BTC hit rate 58→63%, SPY hit rate 63→66% at default Sens 4
//
// REMOVED (redundant / low empirical evidence):
//   Fisher Transform, MACD (redundant with EMA trend), Stochastic RSI,
//   Divergence detection, Hurst Exponent, GARCH proxy, Pi Cycle,
//   Mayer Multiple, asset-specific factor switching.
//
// ═══════════════════════════════════════════════════════════════════════════════

//@version=6
strategy("Adaptive Momentum v4.1 — Backtest", overlay = true,
         default_qty_type = strategy.percent_of_equity, default_qty_value = 100,
         initial_capital = 100000, commission_type = strategy.commission.percent,
         commission_value = 0.1, slippage = 1, process_orders_on_close = true,
         max_bars_back = 5000)

// ═══════════════════════════════════════════
// § 1 — SENSITIVITY & STRATEGY CONTROLS
// ═══════════════════════════════════════════
sensitivityInput = input.string("4 — Standard", "Signal Sensitivity",
     options = ["1 — Ultra Conservative", "2 — Conservative", "3 — Moderate",
                "4 — Standard", "5 — Responsive", "6 — Aggressive", "7 — Scalper"],
     group = "Sensitivity",
     tooltip = "1 = Fewest signals, highest conviction\n4 = Default balanced\n7 = Most signals, lowest threshold")

sensLevel = sensitivityInput == "1 — Ultra Conservative" ? 1 :
            sensitivityInput == "2 — Conservative" ? 2 :
            sensitivityInput == "3 — Moderate" ? 3 :
            sensitivityInput == "4 — Standard" ? 4 :
            sensitivityInput == "5 — Responsive" ? 5 :
            sensitivityInput == "6 — Aggressive" ? 6 : 7

// Sensitivity multipliers
sensThreshMult   = sensLevel == 1 ? 1.6 : sensLevel == 2 ? 1.3 : sensLevel == 3 ? 1.15 : sensLevel == 4 ? 1.0 : sensLevel == 5 ? 0.85 : sensLevel == 6 ? 0.72 : 0.6
sensCooldownMult = sensLevel == 1 ? 2.0 : sensLevel == 2 ? 1.5 : sensLevel == 3 ? 1.2  : sensLevel == 4 ? 1.0 : sensLevel == 5 ? 0.8  : sensLevel == 6 ? 0.6  : 0.4

// Strategy settings
enableShorts = input.bool(false, "Enable Short Trades", group = "Strategy")
forwardBars  = input.int(13, "Hit Rate Forward Bars (N)", minval = 1, maxval = 52, group = "Strategy")
minHoldBars  = input.int(5, "Min Hold Period (bars)", minval = 1, maxval = 20, group = "Strategy",
     tooltip = "Minimum bars in position before Supertrend can trigger exit.\nPrevents short whipsaw trades that lose money.")

// Supertrend settings
stAtrPeriod  = input.int(14, "Supertrend ATR Period", minval = 7, maxval = 21, group = "Supertrend")
stMultiplier = input.float(3.0, "Supertrend Base Multiplier", minval = 2.0, maxval = 5.0, step = 0.5, group = "Supertrend",
     tooltip = "Auto-scales based on asset volatility.\nLow-vol assets (equities) get wider stops.\nHigh-vol assets (crypto) keep tighter stops.")

// Drawdown control
useDrawdownCtrl = input.bool(true, "Drawdown Control", group = "Risk")
maxDrawdownPct  = input.float(15.0, "Max Drawdown %", minval = 5.0, maxval = 30.0, group = "Risk")

// ═══════════════════════════════════════════
// § 2 — CORE INDICATOR CALCULATIONS
// ═══════════════════════════════════════════

// --- Trend Gate: 200-day SMA (Faber 10-month equivalent on daily) ---
sma200 = ta.sma(close, 200)
trendGatePass = close > sma200

// --- ATR (needed for Supertrend auto-scaling and volatility regime) ---
atrVal = ta.atr(14)
atrPct = atrVal / math.max(close, 0.0001) * 100

// --- Supertrend (trailing stop / exit refinement) ---
// Auto-scale multiplier: low-vol assets (equities) need wider stops
// to avoid whipsaw; high-vol assets (crypto) can use tighter stops
medianAtrPct = ta.percentile_linear_interpolation(atrPct, 252, 50)
stAutoAdj = medianAtrPct < 0.8 ? 2.0 : medianAtrPct < 1.5 ? 1.0 : medianAtrPct > 4.0 ? -0.5 : 0.0
effectiveStMult = math.max(2.0, stMultiplier + stAutoAdj)
[stValue, stDirection] = ta.supertrend(effectiveStMult, stAtrPeriod)
stBullish = stDirection < 0
stBearish = stDirection > 0

// --- Momentum: 12-month ROC (~252 trading days) ---
roc252 = ta.roc(close, 252)
roc126 = ta.roc(close, 126)  // 6-month
roc63  = ta.roc(close, 63)   // 3-month
roc21  = ta.roc(close, 21)   // 1-month

// Averaged multi-period ROC (Faber enhanced momentum)
avgRoc = nz(roc21) * 0.1 + nz(roc63) * 0.2 + nz(roc126) * 0.3 + nz(roc252) * 0.4

// --- RSI(14) as trend filter, NOT overbought/oversold oscillator ---
rsiVal = ta.rsi(close, 14)
rsiAbove50 = rsiVal > 50

// Rare contrarian flag: monthly RSI < 30 (mean-reversion buy opportunity)
rsiExtremeLow = rsiVal < 30

// --- OBV with 20-period EMA slope ---
obvVal = ta.obv
obvEma20 = ta.ema(obvVal, 20)
obvEma5  = ta.ema(obvVal, 5)
obvSlope = obvEma5 > obvEma20  // OBV trending up

// --- Chaikin Money Flow (21-period) ---
mfMultiplier = ((close - low) - (high - close)) / math.max(high - low, 0.0001)
mfVolume = mfMultiplier * volume
cmf21 = ta.sma(mfVolume, 21) / math.max(ta.sma(volume, 21), 1)

// --- ATR Volatility Regime ---
atrPercentile = ta.percentrank(atrPct, 100)

// Low volatility: below 30th percentile (squeeze territory, tighter thresholds)
// High volatility: above 70th percentile (widen stops, require stronger confirmation)
volRegimeLow  = atrPercentile < 30
volRegimeHigh = atrPercentile > 70

// --- Bollinger Band Squeeze Detection ---
bbLen = 20
bbBasis = ta.sma(close, bbLen)
bbDev = 2.0 * ta.stdev(close, bbLen)
bbUpper = bbBasis + bbDev
bbLower = bbBasis - bbDev
// Keltner for squeeze confirmation
kcRange = ta.atr(bbLen)
kcUpper = bbBasis + kcRange * 1.5
kcLower = bbBasis - kcRange * 1.5
squeezeConfirmed = bbLower > kcLower and bbUpper < kcUpper

// Squeeze release detection
squeezePrev = squeezeConfirmed[1]
squeezeRelease = squeezePrev and not squeezeConfirmed

// Squeeze momentum direction (linreg of price deviation)
sqzHighest = ta.highest(high, bbLen)
sqzLowest  = ta.lowest(low, bbLen)
sqzMidline = math.avg(sqzHighest, sqzLowest)
sqzMom = ta.linreg(close - math.avg(sqzMidline, bbBasis), bbLen, 0)

// --- Volume Gate (auto-detect low-liquidity environments) ---
volSma50 = ta.sma(volume, 50)
volSma10 = ta.sma(volume, 10)
lowVolumeEnv = nz(volSma10) < 0.3 * nz(volSma50) or volume < 1000
volumeAdequate = not lowVolumeEnv

// Volume confirmation (relative to average)
volRatio = volume / math.max(nz(volSma50, 1), 1)
volSpike = volRatio >= 2.0

// ═══════════════════════════════════════════
// § 3-4 — MOMENTUM CONFIRMATION
// ═══════════════════════════════════════════
// Jegadeesh-Titman: 12-month ROC positive AND RSI(14) > 50.
// Both must confirm to distinguish genuine momentum from sideways drift.

momentumConfirmed = avgRoc > 0 and rsiAbove50

// Momentum score: averaged multi-period ROC direction + RSI confirmation
momRocScore = avgRoc > 0 ? 1.0 : -1.0
momRsiScore = rsiAbove50 ? 1.0 : -1.0
momentumScore = momRocScore * 0.6 + momRsiScore * 0.4

// Rare contrarian override: RSI extreme low in uptrend (mean-reversion buy)
contrarianBuyFlag = rsiExtremeLow and trendGatePass

// ═══════════════════════════════════════════
// § 5 — LAYER 3: CONVICTION SCORING
// ═══════════════════════════════════════════
// Within confirmed trend+momentum, score conviction 0–10 from:
// - OBV slope (volume precedes price)
// - CMF sign (institutional accumulation/distribution)
// - ATR percentile (volatility regime)
// - BB Squeeze state
// - Supertrend alignment

// OBV contribution (0 to 1)
obvScore = obvSlope ? 1.0 : (obvEma5 < obvEma20 ? -0.5 : 0.0)

// CMF contribution (0 to 1)
cmfScore = cmf21 > 0.05 ? 1.0 : (cmf21 > 0 ? 0.5 : (cmf21 > -0.05 ? -0.25 : -1.0))

// Volume confirmation bonus
volConfirmScore = volSpike and close > close[1] ? 0.5 :
                  volSpike and close < close[1] ? -0.5 : 0.0

// ATR regime contribution (low vol = favorable, high vol = cautious)
atrScore = volRegimeLow ? 0.5 : (volRegimeHigh ? -0.5 : 0.0)

// Squeeze contribution
squeezeScore = 0.0
if squeezeRelease
    squeezeScore := nz(sqzMom) > 0 ? 1.0 : -1.0
else if squeezeConfirmed
    squeezeScore := 0.25  // Compression building, mildly bullish (energy loading)

// Supertrend alignment
stScore = stBullish ? 0.5 : -0.5

// ═══════════════════════════════════════════
// § 6 — COMPOSITE SCORE (0–10)
// ═══════════════════════════════════════════
// Hierarchical: trend gate dominates, momentum provides direction,
// conviction modulates within confirmed signals.

rawScore = 0.0
if trendGatePass
    // Uptrend — score from 3.0 to 10.0 based on momentum and conviction
    baseScore = 5.0  // Neutral hold in uptrend
    momContrib = momentumScore * 1.5   // -1.5 to +1.5
    obvContrib = obvScore * 0.6        // -0.3 to +0.6
    cmfContrib = cmfScore * 0.4        // -0.4 to +0.4
    volContrib = volConfirmScore * 0.3  // -0.15 to +0.15
    atrContrib = atrScore * 0.3        // -0.15 to +0.15
    sqzContrib = squeezeScore * 0.5    // -0.5 to +0.5
    stContrib  = stScore * 0.4         // -0.2 to +0.2

    rawScore := baseScore + momContrib + obvContrib + cmfContrib +
                volContrib + atrContrib + sqzContrib + stContrib

    // Contrarian RSI extreme bonus (rare, high-conviction)
    if contrarianBuyFlag
        rawScore := math.max(rawScore, 7.0)  // Floor at Accumulate zone
else
    // Downtrend — score from 0.0 to 4.0
    baseScore = 2.0  // Distribute zone baseline
    momContrib = momentumScore * 0.8   // Momentum can push toward Hold or Strong Sell
    stContrib  = stScore * 0.4
    sqzContrib = squeezeScore * 0.3

    rawScore := baseScore + momContrib + stContrib + sqzContrib

// Clamp to 0–10
rawScoreClamped = math.max(0.0, math.min(10.0, rawScore))

// ═══════════════════════════════════════════
// § 6b — VOLATILITY-ADAPTIVE SCORE SMOOTHING
// ═══════════════════════════════════════════
// Base smoothing period scales with sensitivity
// Then auto-adjusts based on asset volatility: low-vol assets (equities)
// need more smoothing (noisier scores), high-vol assets (crypto) need less
//
// NOTE: ta.ema() requires simple int length. Since smoothAdjust depends on
// medianAtrPct (series float), we pre-compute all possible EMA periods (2-7)
// and select at runtime via ternary. All EMAs are O(1) per bar.
baseSmoothPeriod = sensLevel == 2 ? 2 : sensLevel <= 3 ? 1 : sensLevel == 4 ? 2 : sensLevel <= 6 ? 3 : 4
smoothAdjust = medianAtrPct < 1.5 ? 3 : medianAtrPct < 2.5 ? 1 : 0
scoreSmoothPeriod = baseSmoothPeriod + smoothAdjust

// Pre-compute all possible EMA periods (simple int lengths)
scoreEma2 = ta.ema(rawScoreClamped, 2)
scoreEma3 = ta.ema(rawScoreClamped, 3)
scoreEma4 = ta.ema(rawScoreClamped, 4)
scoreEma5 = ta.ema(rawScoreClamped, 5)
scoreEma6 = ta.ema(rawScoreClamped, 6)
scoreEma7 = ta.ema(rawScoreClamped, 7)

// Select the correct pre-computed EMA based on runtime period
compositeScore = scoreSmoothPeriod <= 1 ? rawScoreClamped :
                 scoreSmoothPeriod == 2 ? scoreEma2 :
                 scoreSmoothPeriod == 3 ? scoreEma3 :
                 scoreSmoothPeriod == 4 ? scoreEma4 :
                 scoreSmoothPeriod == 5 ? scoreEma5 :
                 scoreSmoothPeriod == 6 ? scoreEma6 : scoreEma7
compositeScore := math.max(0.0, math.min(10.0, compositeScore))

// ═══════════════════════════════════════════
// § 7 — ZONE CLASSIFICATION & SIGNAL GENERATION
// ═══════════════════════════════════════════
// Zone thresholds scaled by sensitivity
zoneStrongBuy  = 8.0 * sensThreshMult
zoneAccumulate = 6.0 * sensThreshMult
zoneHold       = 4.0 * sensThreshMult
zoneDistribute = 2.0 * sensThreshMult

// Clamp zone thresholds
zoneStrongBuy  := math.min(zoneStrongBuy, 9.5)
zoneAccumulate := math.min(zoneAccumulate, zoneStrongBuy - 0.5)
zoneHold       := math.min(zoneHold, zoneAccumulate - 0.5)
zoneDistribute := math.min(zoneDistribute, zoneHold - 0.5)

// Zone hysteresis: asymmetric entry/exit thresholds prevent rapid zone flipping
// Only active at Sens 4+ where noise is higher; Sens 1-3 use standard thresholds
hystSpread = sensLevel >= 4 ? 0.5 : 0.0
zoneStrongBuyExit  = zoneStrongBuy - hystSpread
zoneAccumulateExit = zoneAccumulate - hystSpread
zoneDistributeExit = zoneDistribute + hystSpread

// Zone hysteresis state tracking
var string prevZone = "hold"

// Zone classification with hysteresis
// When in bullish zone, use lower exit thresholds (sticky bullish)
// When in neutral/bearish zone, use standard entry thresholds
bool isStrongBuy  = false
bool isAccumulate = false
bool isHold       = false
bool isDistribute = false
bool isStrongSell = false

if prevZone == "strong_buy" or prevZone == "accumulate"
    isStrongBuy  := compositeScore >= zoneStrongBuyExit
    isAccumulate := compositeScore >= zoneAccumulateExit and not isStrongBuy
    isDistribute := compositeScore < zoneHold and compositeScore >= zoneDistributeExit
    isStrongSell := compositeScore < zoneDistributeExit
    isHold       := not isStrongBuy and not isAccumulate and not isDistribute and not isStrongSell
else
    isStrongBuy  := compositeScore >= zoneStrongBuy
    isAccumulate := compositeScore >= zoneAccumulate and not isStrongBuy
    isDistribute := compositeScore >= zoneDistribute and compositeScore < zoneHold
    isStrongSell := compositeScore < zoneDistribute
    isHold       := not isStrongBuy and not isAccumulate and not isDistribute and not isStrongSell

// Update zone state
if isStrongBuy
    prevZone := "strong_buy"
else if isAccumulate
    prevZone := "accumulate"
else if isStrongSell
    prevZone := "strong_sell"
else if isDistribute
    prevZone := "distribute"
else
    prevZone := "hold"

// Signal generation with cooldown
baseCooldown = 12  // Increased from 8 to reduce whipsaw
cooldown = math.max(3, math.round(baseCooldown * sensCooldownMult))

var int barsSinceSignal = 999
var int lastSignalDir = 0
var int barsInTrade = 0  // Track hold duration for min hold enforcement
barsSinceSignal := barsSinceSignal + 1
if lastSignalDir == 1
    barsInTrade := barsInTrade + 1
cooldownMet = barsSinceSignal >= cooldown

// Buy signals: Strong Buy or Accumulate zone
buySignal  = (isStrongBuy or isAccumulate) and cooldownMet and lastSignalDir != 1 and volumeAdequate

// Sell signals: require BOTH score drop AND trend gate failure
// Prevents premature exits when score dips briefly but trend is intact
sellSignal = isStrongSell and not trendGatePass and lastSignalDir != -1

// Supertrend trailing stop exit: only after minimum hold period
// Short trades (<5 bars) have negative expectancy — min hold prevents this
stExitSignal = stBearish and lastSignalDir == 1 and barsInTrade >= minHoldBars

// Prevent simultaneous buy+sell
buySignal  := buySignal and not sellSignal
sellSignal := (sellSignal or stExitSignal) and not buySignal

// Drawdown control (equity-based)
var float peakEquity = strategy.initial_capital
var float currentDD  = 0.0
currentEquity = strategy.equity
if currentEquity > peakEquity
    peakEquity := currentEquity
    currentDD  := 0.0
else
    currentDD := (peakEquity - currentEquity) / peakEquity * 100

drawdownTriggered = useDrawdownCtrl and currentDD >= maxDrawdownPct
if drawdownTriggered and lastSignalDir == 1
    sellSignal := true
    buySignal  := false

// High volatility regime gate: require stronger signals
if volRegimeHigh and buySignal and not isStrongBuy
    buySignal := false  // Only Strong Buy passes in high-vol regime

// Update state
if buySignal
    lastSignalDir   := 1
    barsSinceSignal := 0
    barsInTrade     := 0

if sellSignal
    lastSignalDir   := -1
    barsSinceSignal := 0
    barsInTrade     := 0

// ═══════════════════════════════════════════
// § 8 — STRATEGY EXECUTION
// ═══════════════════════════════════════════
if buySignal
    strategy.entry("Long", strategy.long)

if sellSignal
    strategy.close("Long")
    if enableShorts
        strategy.entry("Short", strategy.short)

if buySignal and enableShorts
    strategy.close("Short")

// ═══════════════════════════════════════════
// § 9 — FORWARD RETURN TRACKING
// ═══════════════════════════════════════════
var int MAX_SIGNALS = 500

var int[]   buyBarArr    = array.new<int>()
var float[] buyPriceArr  = array.new<float>()
var int[]   sellBarArr   = array.new<int>()
var float[] sellPriceArr = array.new<float>()

var float buyFwd4Sum    = 0.0, var int buyFwd4Count   = 0
var float buyFwd8Sum    = 0.0, var int buyFwd8Count   = 0
var float buyFwd13Sum   = 0.0, var int buyFwd13Count  = 0
var float buyFwd26Sum   = 0.0, var int buyFwd26Count  = 0
var int   buyCorrectN   = 0,   var int buyTotalN      = 0

var float sellFwd4Sum   = 0.0, var int sellFwd4Count  = 0
var float sellFwd8Sum   = 0.0, var int sellFwd8Count  = 0
var float sellFwd13Sum  = 0.0, var int sellFwd13Count = 0
var float sellFwd26Sum  = 0.0, var int sellFwd26Count = 0
var int   sellCorrectN  = 0,   var int sellTotalN     = 0

if buySignal
    if array.size(buyBarArr) >= MAX_SIGNALS
        array.shift(buyBarArr)
        array.shift(buyPriceArr)
    array.push(buyBarArr, bar_index)
    array.push(buyPriceArr, close)

if sellSignal
    if array.size(sellBarArr) >= MAX_SIGNALS
        array.shift(sellBarArr)
        array.shift(sellPriceArr)
    array.push(sellBarArr, bar_index)
    array.push(sellPriceArr, close)

// Optimized scan: skip fully-processed signals
var int buyScanStart  = 0
var int sellScanStart = 0
maxFwdPeriod = math.max(26, forwardBars)

if array.size(buyBarArr) > 0
    for i = buyScanStart to array.size(buyBarArr) - 1
        if bar_index - array.get(buyBarArr, i) > maxFwdPeriod
            buyScanStart := i + 1
        else
            break
    if buyScanStart < array.size(buyBarArr)
        for i = buyScanStart to array.size(buyBarArr) - 1
            sigBar = array.get(buyBarArr, i)
            sigPrice = array.get(buyPriceArr, i)
            elapsed = bar_index - sigBar
            if elapsed == 4
                buyFwd4Sum := buyFwd4Sum + (close - sigPrice) / sigPrice * 100
                buyFwd4Count := buyFwd4Count + 1
            if elapsed == 8
                buyFwd8Sum := buyFwd8Sum + (close - sigPrice) / sigPrice * 100
                buyFwd8Count := buyFwd8Count + 1
            if elapsed == 13
                buyFwd13Sum := buyFwd13Sum + (close - sigPrice) / sigPrice * 100
                buyFwd13Count := buyFwd13Count + 1
            if elapsed == 26
                buyFwd26Sum := buyFwd26Sum + (close - sigPrice) / sigPrice * 100
                buyFwd26Count := buyFwd26Count + 1
            if elapsed == forwardBars
                buyTotalN := buyTotalN + 1
                if close > sigPrice
                    buyCorrectN := buyCorrectN + 1

if array.size(sellBarArr) > 0
    for i = sellScanStart to array.size(sellBarArr) - 1
        if bar_index - array.get(sellBarArr, i) > maxFwdPeriod
            sellScanStart := i + 1
        else
            break
    if sellScanStart < array.size(sellBarArr)
        for i = sellScanStart to array.size(sellBarArr) - 1
            sigBar = array.get(sellBarArr, i)
            sigPrice = array.get(sellPriceArr, i)
            elapsed = bar_index - sigBar
            if elapsed == 4
                sellFwd4Sum := sellFwd4Sum + (close - sigPrice) / sigPrice * 100
                sellFwd4Count := sellFwd4Count + 1
            if elapsed == 8
                sellFwd8Sum := sellFwd8Sum + (close - sigPrice) / sigPrice * 100
                sellFwd8Count := sellFwd8Count + 1
            if elapsed == 13
                sellFwd13Sum := sellFwd13Sum + (close - sigPrice) / sigPrice * 100
                sellFwd13Count := sellFwd13Count + 1
            if elapsed == 26
                sellFwd26Sum := sellFwd26Sum + (close - sigPrice) / sigPrice * 100
                sellFwd26Count := sellFwd26Count + 1
            if elapsed == forwardBars
                sellTotalN := sellTotalN + 1
                if close < sigPrice
                    sellCorrectN := sellCorrectN + 1

// ═══════════════════════════════════════════
// § 10 — STATS TABLE
// ═══════════════════════════════════════════
if barstate.islast
    totalTrades = strategy.closedtrades
    grossProfit = strategy.grossprofit
    grossLoss   = math.abs(strategy.grossloss)
    profitFactor = grossLoss > 0 ? grossProfit / grossLoss : (grossProfit > 0 ? 999.0 : 0.0)

    wins = 0, losses = 0
    winPctSum = 0.0, lossPctSum = 0.0
    if totalTrades > 0
        for i = 0 to totalTrades - 1
            tradePnl = strategy.closedtrades.profit(i)
            tradeEntry = strategy.closedtrades.entry_price(i)
            if tradeEntry > 0
                tradePct = tradePnl / tradeEntry * 100
                if tradePnl >= 0
                    wins := wins + 1
                    winPctSum := winPctSum + tradePct
                else
                    losses := losses + 1
                    lossPctSum := lossPctSum + tradePct

    winRate    = totalTrades > 0 ? wins * 100.0 / totalTrades : 0.0
    avgWinPct  = wins > 0 ? winPctSum / wins : 0.0
    avgLossPct = losses > 0 ? lossPctSum / losses : 0.0
    maxDD = strategy.max_drawdown

    buyAvg4  = buyFwd4Count > 0 ? buyFwd4Sum / buyFwd4Count : na
    buyAvg8  = buyFwd8Count > 0 ? buyFwd8Sum / buyFwd8Count : na
    buyAvg13 = buyFwd13Count > 0 ? buyFwd13Sum / buyFwd13Count : na
    buyAvg26 = buyFwd26Count > 0 ? buyFwd26Sum / buyFwd26Count : na
    sellAvg4  = sellFwd4Count > 0 ? sellFwd4Sum / sellFwd4Count : na
    sellAvg8  = sellFwd8Count > 0 ? sellFwd8Sum / sellFwd8Count : na
    sellAvg13 = sellFwd13Count > 0 ? sellFwd13Sum / sellFwd13Count : na
    sellAvg26 = sellFwd26Count > 0 ? sellFwd26Sum / sellFwd26Count : na
    buyHitRate  = buyTotalN > 0 ? buyCorrectN * 100.0 / buyTotalN : na
    sellHitRate = sellTotalN > 0 ? sellCorrectN * 100.0 / sellTotalN : na

    var table stats = table.new(position.bottom_right, 3, 24,
                                bgcolor = color.new(#0D1117, 5),
                                border_width = 1,
                                border_color = color.new(#30363D, 0))

    headerBg = color.new(#161B22, 0)
    headerFg = color.new(#58A6FF, 0)
    labelFg  = color.new(#8B949E, 0)
    valueFg  = color.new(#C9D1D9, 0)
    greenFg  = color.new(#3FB950, 0)
    redFg    = color.new(#F85149, 0)
    yellowFg = color.new(#D29922, 0)
    dimFg    = color.new(#484F58, 0)
    row = 0

    // Zone display
    zoneStr = isStrongBuy ? "STRONG BUY" : isAccumulate ? "ACCUMULATE" : isHold ? "HOLD" : isDistribute ? "DISTRIBUTE" : "STRONG SELL"
    zoneColor = isStrongBuy ? greenFg : isAccumulate ? color.new(#2EA043, 0) : isHold ? yellowFg : isDistribute ? color.new(#DA3633, 0) : redFg

    table.cell(stats, 0, row, "ZONE: " + zoneStr + "  Score: " + str.tostring(compositeScore, "#.1"), text_color = zoneColor, text_size = size.small, bgcolor = headerBg)
    table.cell(stats, 1, row, "", bgcolor = headerBg)
    table.cell(stats, 2, row, "", bgcolor = headerBg)
    table.merge_cells(stats, 0, row, 2, row)
    row := row + 1

    // Layer status
    trendStr = trendGatePass ? "PASS" : "FAIL"
    momStr = momentumConfirmed ? "PASS" : "FAIL"
    volStr = volRegimeHigh ? "HIGH" : volRegimeLow ? "LOW" : "NORMAL"
    table.cell(stats, 0, row, "Trend Gate: " + trendStr, text_color = trendGatePass ? greenFg : redFg, text_size = size.tiny)
    table.cell(stats, 1, row, "Momentum: " + momStr, text_color = momentumConfirmed ? greenFg : redFg, text_size = size.tiny)
    table.cell(stats, 2, row, "Vol: " + volStr, text_color = volRegimeHigh ? redFg : volRegimeLow ? yellowFg : greenFg, text_size = size.tiny)
    row := row + 1

    // Strategy Performance header
    table.cell(stats, 0, row, "STRATEGY PERFORMANCE", text_color = headerFg, text_size = size.small, bgcolor = headerBg)
    table.cell(stats, 1, row, "", bgcolor = headerBg)
    table.cell(stats, 2, row, "", bgcolor = headerBg)
    table.merge_cells(stats, 0, row, 2, row)
    row := row + 1

    table.cell(stats, 0, row, "Total Trades", text_color = labelFg, text_size = size.tiny)
    table.cell(stats, 1, row, str.tostring(totalTrades), text_color = valueFg, text_size = size.tiny)
    table.cell(stats, 2, row, str.tostring(wins) + "W / " + str.tostring(losses) + "L", text_color = dimFg, text_size = size.tiny)
    row := row + 1

    wrColor = winRate >= 50 ? greenFg : redFg
    table.cell(stats, 0, row, "Win Rate", text_color = labelFg, text_size = size.tiny)
    table.cell(stats, 1, row, str.tostring(winRate, "#.1") + "%", text_color = wrColor, text_size = size.tiny)
    table.cell(stats, 2, row, "", text_size = size.tiny)
    row := row + 1

    pfColor = profitFactor >= 1.5 ? greenFg : (profitFactor >= 1.0 ? yellowFg : redFg)
    table.cell(stats, 0, row, "Profit Factor", text_color = labelFg, text_size = size.tiny)
    table.cell(stats, 1, row, profitFactor >= 100 ? ">99" : str.tostring(profitFactor, "#.##"), text_color = pfColor, text_size = size.tiny)
    table.cell(stats, 2, row, "", text_size = size.tiny)
    row := row + 1

    table.cell(stats, 0, row, "Avg Win %", text_color = labelFg, text_size = size.tiny)
    table.cell(stats, 1, row, str.tostring(avgWinPct, "#.##") + "%", text_color = greenFg, text_size = size.tiny)
    table.cell(stats, 2, row, "", text_size = size.tiny)
    row := row + 1

    table.cell(stats, 0, row, "Avg Loss %", text_color = labelFg, text_size = size.tiny)
    table.cell(stats, 1, row, str.tostring(avgLossPct, "#.##") + "%", text_color = redFg, text_size = size.tiny)
    table.cell(stats, 2, row, "", text_size = size.tiny)
    row := row + 1

    table.cell(stats, 0, row, "Max Drawdown", text_color = labelFg, text_size = size.tiny)
    table.cell(stats, 1, row, str.tostring(maxDD, "#.##"), text_color = redFg, text_size = size.tiny)
    table.cell(stats, 2, row, "(currency)", text_color = dimFg, text_size = size.tiny)
    row := row + 1

    netPnl = strategy.netprofit
    netColor = netPnl >= 0 ? greenFg : redFg
    table.cell(stats, 0, row, "Net Profit", text_color = labelFg, text_size = size.tiny)
    table.cell(stats, 1, row, str.tostring(netPnl, "#.##"), text_color = netColor, text_size = size.tiny)
    netPct = strategy.initial_capital > 0 ? netPnl / strategy.initial_capital * 100 : 0.0
    table.cell(stats, 2, row, str.tostring(netPct, "#.#") + "%", text_color = netColor, text_size = size.tiny)
    row := row + 1

    // Hit Rate header
    table.cell(stats, 0, row, "SIGNAL HIT RATE (" + str.tostring(forwardBars) + "-bar)", text_color = headerFg, text_size = size.small, bgcolor = headerBg)
    table.cell(stats, 1, row, "", bgcolor = headerBg)
    table.cell(stats, 2, row, "", bgcolor = headerBg)
    table.merge_cells(stats, 0, row, 2, row)
    row := row + 1

    buyHrColor = not na(buyHitRate) ? (buyHitRate >= 55 ? greenFg : (buyHitRate >= 45 ? yellowFg : redFg)) : dimFg
    table.cell(stats, 0, row, "BUY Hit Rate", text_color = labelFg, text_size = size.tiny)
    table.cell(stats, 1, row, not na(buyHitRate) ? str.tostring(buyHitRate, "#.1") + "%" : "N/A", text_color = buyHrColor, text_size = size.tiny)
    table.cell(stats, 2, row, str.tostring(buyCorrectN) + "/" + str.tostring(buyTotalN), text_color = dimFg, text_size = size.tiny)
    row := row + 1

    sellHrColor = not na(sellHitRate) ? (sellHitRate >= 55 ? greenFg : (sellHitRate >= 45 ? yellowFg : redFg)) : dimFg
    table.cell(stats, 0, row, "SELL Hit Rate", text_color = labelFg, text_size = size.tiny)
    table.cell(stats, 1, row, not na(sellHitRate) ? str.tostring(sellHitRate, "#.1") + "%" : "N/A", text_color = sellHrColor, text_size = size.tiny)
    table.cell(stats, 2, row, str.tostring(sellCorrectN) + "/" + str.tostring(sellTotalN), text_color = dimFg, text_size = size.tiny)
    row := row + 1

    // Buy Forward Returns
    table.cell(stats, 0, row, "BUY FORWARD RETURNS", text_color = headerFg, text_size = size.small, bgcolor = headerBg)
    table.cell(stats, 1, row, "Avg %", text_color = headerFg, text_size = size.small, bgcolor = headerBg)
    table.cell(stats, 2, row, "n", text_color = headerFg, text_size = size.small, bgcolor = headerBg)
    row := row + 1

    for period_idx = 0 to 3
        pLabel = period_idx == 0 ? "  4-bar" : period_idx == 1 ? "  8-bar" : period_idx == 2 ? "  13-bar" : "  26-bar"
        pAvg = period_idx == 0 ? buyAvg4 : period_idx == 1 ? buyAvg8 : period_idx == 2 ? buyAvg13 : buyAvg26
        pN = period_idx == 0 ? buyFwd4Count : period_idx == 1 ? buyFwd8Count : period_idx == 2 ? buyFwd13Count : buyFwd26Count
        pColor = not na(pAvg) ? (pAvg > 0 ? greenFg : redFg) : dimFg
        table.cell(stats, 0, row, pLabel, text_color = labelFg, text_size = size.tiny)
        table.cell(stats, 1, row, not na(pAvg) ? str.tostring(pAvg, "#.##") + "%" : "---", text_color = pColor, text_size = size.tiny)
        table.cell(stats, 2, row, str.tostring(pN), text_color = dimFg, text_size = size.tiny)
        row := row + 1

    // Sell Forward Returns
    table.cell(stats, 0, row, "SELL FORWARD RETURNS", text_color = headerFg, text_size = size.small, bgcolor = headerBg)
    table.cell(stats, 1, row, "Avg %", text_color = headerFg, text_size = size.small, bgcolor = headerBg)
    table.cell(stats, 2, row, "n", text_color = headerFg, text_size = size.small, bgcolor = headerBg)
    row := row + 1

    for period_idx = 0 to 3
        pLabel = period_idx == 0 ? "  4-bar" : period_idx == 1 ? "  8-bar" : period_idx == 2 ? "  13-bar" : "  26-bar"
        pAvg = period_idx == 0 ? sellAvg4 : period_idx == 1 ? sellAvg8 : period_idx == 2 ? sellAvg13 : sellAvg26
        pN = period_idx == 0 ? sellFwd4Count : period_idx == 1 ? sellFwd8Count : period_idx == 2 ? sellFwd13Count : sellFwd26Count
        pColor = not na(pAvg) ? (pAvg < 0 ? greenFg : redFg) : dimFg
        table.cell(stats, 0, row, pLabel, text_color = labelFg, text_size = size.tiny)
        table.cell(stats, 1, row, not na(pAvg) ? str.tostring(pAvg, "#.##") + "%" : "---", text_color = pColor, text_size = size.tiny)
        table.cell(stats, 2, row, str.tostring(pN), text_color = dimFg, text_size = size.tiny)
        row := row + 1

    // Footer
    table.cell(stats, 0, row, "Total BUY signals", text_color = dimFg, text_size = size.tiny)
    table.cell(stats, 1, row, str.tostring(array.size(buyBarArr)), text_color = dimFg, text_size = size.tiny)
    table.cell(stats, 2, row, "", text_size = size.tiny)
    row := row + 1
    table.cell(stats, 0, row, "Total SELL signals", text_color = dimFg, text_size = size.tiny)
    table.cell(stats, 1, row, str.tostring(array.size(sellBarArr)), text_color = dimFg, text_size = size.tiny)
    table.cell(stats, 2, row, "", text_size = size.tiny)

// ═══════════════════════════════════════════
// § 11 — VISUAL OUTPUT
// ═══════════════════════════════════════════

// Zone background color
zoneBgColor = isStrongBuy ? color.new(#3FB950, 92) :
              isAccumulate ? color.new(#2EA043, 94) :
              isHold ? color.new(#D29922, 95) :
              isDistribute ? color.new(#DA3633, 94) :
              color.new(#F85149, 92)
bgcolor(zoneBgColor, title = "Zone Background")

// Signal markers
plotshape(buySignal,  title = "Buy Signal",  style = shape.triangleup,   location = location.belowbar, color = color.new(#3FB950, 0), size = size.small)
plotshape(sellSignal, title = "Sell Signal", style = shape.triangledown, location = location.abovebar, color = color.new(#F85149, 0), size = size.small)

// Trend gate line
plot(sma200, title = "200 SMA (Trend Gate)", color = trendGatePass ? color.new(#3FB950, 50) : color.new(#F85149, 50), linewidth = 2)

// Supertrend trailing stop
plot(stBullish ? stValue : na, title = "Supertrend Bull", color = color.new(#3FB950, 70), style = plot.style_linebr, linewidth = 1)
plot(stBearish ? stValue : na, title = "Supertrend Bear", color = color.new(#F85149, 70), style = plot.style_linebr, linewidth = 1)

// Volume warning
plotshape(lowVolumeEnv and not lowVolumeEnv[1], title = "Low Volume Warning", style = shape.xcross, location = location.abovebar, color = color.new(#D29922, 30), size = size.tiny)
