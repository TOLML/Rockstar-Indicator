// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ADAPTIVE MOMENTUM v3.1 â€” BACKTEST STRATEGY
// Converted from: Adaptive_Momentum_Overlay.pine (indicator)
// PineScript: v6
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// DESCRIPTION:
//   Strategy version of the Multi-Asset Adaptive Momentum v3.1 indicator.
//   Identical signal logic â€” converted to strategy.entry/close for backtesting.
//   Includes comprehensive stats table with forward-return hit-rate analysis.
//   Now with 7-level sensitivity presets matching the overlay.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

//@version=6
strategy("Adaptive Momentum v3.1 â€” Backtest", overlay = true,
         default_qty_type = strategy.percent_of_equity, default_qty_value = 100,
         initial_capital = 100000, commission_type = strategy.commission.percent,
         commission_value = 0.1, slippage = 1, process_orders_on_close = false,
         max_bars_back = 5000)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Â§ 1 â€” MODE SELECTION & SENSITIVITY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
modeInput = input.string("ğŸŸ  CRYPTO (Bitcoin)", "Asset Mode", options = ["ğŸŸ  CRYPTO (Bitcoin)", "â›ï¸ MINING (Micro-Cap)", "ğŸ“ˆ ETF (Large-Cap Growth)"])

isCrypto  = modeInput == "ğŸŸ  CRYPTO (Bitcoin)"
isMining  = modeInput == "â›ï¸ MINING (Micro-Cap)"
isETF     = modeInput == "ğŸ“ˆ ETF (Large-Cap Growth)"

// SENSITIVITY PRESET â€” Controls signal frequency vs. accuracy tradeoff
sensitivityInput = input.string("4 â€” Standard", "ğŸšï¸ Signal Sensitivity",
     options = ["1 â€” Ultra Conservative", "2 â€” Conservative", "3 â€” Moderate",
                "4 â€” Standard", "5 â€” Responsive", "6 â€” Aggressive", "7 â€” Scalper"],
     group = "Sensitivity",
     tooltip = "1=Fewest signals (highest conviction)\n4=Default balanced\n7=Most signals (lowest threshold)")

sensLevel = sensitivityInput == "1 â€” Ultra Conservative" ? 1 : sensitivityInput == "2 â€” Conservative" ? 2 : sensitivityInput == "3 â€” Moderate" ? 3 : sensitivityInput == "4 â€” Standard" ? 4 : sensitivityInput == "5 â€” Responsive" ? 5 : sensitivityInput == "6 â€” Aggressive" ? 6 : 7

sensThreshMult   = sensLevel == 1 ? 1.8 : sensLevel == 2 ? 1.4 : sensLevel == 3 ? 1.2 : sensLevel == 4 ? 1.0 : sensLevel == 5 ? 0.85 : sensLevel == 6 ? 0.7 : 0.65
sensCooldownMult = sensLevel == 1 ? 2.0 : sensLevel == 2 ? 1.5 : sensLevel == 3 ? 1.2 : sensLevel == 4 ? 1.0 : sensLevel == 5 ? 0.8 : sensLevel == 6 ? 0.6 : 0.5
sensEliteMult    = sensLevel == 1 ? 1.5 : sensLevel == 2 ? 1.6 : sensLevel == 3 ? 1.5 : sensLevel == 4 ? 1.5 : sensLevel == 5 ? 1.4 : sensLevel == 6 ? 1.3 : 1.2

// Strategy Mode
enableShorts = input.bool(false, "Enable Short Trades", group = "Strategy")
forwardBars  = input.int(13, "Hit Rate Forward Bars (N)", minval = 1, maxval = 52, group = "Strategy", tooltip = "Number of bars to look ahead for directional hit rate")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Â§ 2 â€” CUSTOM PARAMETER OVERRIDE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
useCustom = input.bool(false, "Use Custom Parameters", group = "Override")

// Signal Thresholds
customBuyThresh   = input.int(7, "Buy Threshold", minval = 1, maxval = 20, group = "Override")
customSellThresh  = input.int(-7, "Sell Threshold", minval = -20, maxval = -1, group = "Override")
customCooldown    = input.int(10, "Cooldown Bars", minval = 1, maxval = 52, group = "Override")

// Indicator Periods
customRsiLen      = input.int(14, "RSI Length", minval = 2, maxval = 50, group = "Override â€” Indicators")
customRsiOB       = input.int(70, "RSI Overbought", minval = 50, maxval = 95, group = "Override â€” Indicators")
customRsiOS       = input.int(30, "RSI Oversold", minval = 5, maxval = 50, group = "Override â€” Indicators")
customMacdFast    = input.int(12, "MACD Fast", minval = 2, maxval = 50, group = "Override â€” Indicators")
customMacdSlow    = input.int(26, "MACD Slow", minval = 5, maxval = 100, group = "Override â€” Indicators")
customMacdSig     = input.int(9, "MACD Signal", minval = 2, maxval = 50, group = "Override â€” Indicators")
customRocLen      = input.int(14, "ROC Length", minval = 2, maxval = 50, group = "Override â€” Indicators")
customEmaFast     = input.int(20, "EMA Fast", minval = 2, maxval = 100, group = "Override â€” Indicators")
customEmaSlow     = input.int(50, "EMA Slow", minval = 5, maxval = 200, group = "Override â€” Indicators")
customAdxLen      = input.int(14, "ADX Length", minval = 2, maxval = 50, group = "Override â€” Indicators")
customAdxThresh   = input.int(20, "ADX Threshold", minval = 5, maxval = 50, group = "Override â€” Indicators")
customBbLen       = input.int(20, "BB Length", minval = 5, maxval = 50, group = "Override â€” Indicators")
customBbStd       = input.float(2.0, "BB StdDev", minval = 0.5, maxval = 4.0, step = 0.1, group = "Override â€” Indicators")
customStochLen    = input.int(14, "StochRSI Length", minval = 2, maxval = 50, group = "Override â€” Indicators")
customVolLen      = input.int(20, "Volume MA Length", minval = 5, maxval = 50, group = "Override â€” Indicators")
customVolSpike    = input.float(2.0, "Volume Spike Multiplier", minval = 1.0, maxval = 5.0, step = 0.1, group = "Override â€” Indicators")

// Factor Weights
customWMom        = input.float(1.0, "Momentum Weight", minval = 0.0, maxval = 3.0, step = 0.1, group = "Override â€” Weights")
customWTrend      = input.float(1.5, "Trend Weight", minval = 0.0, maxval = 3.0, step = 0.1, group = "Override â€” Weights")
customWMeanRev    = input.float(1.0, "Mean Reversion Weight", minval = 0.0, maxval = 3.0, step = 0.1, group = "Override â€” Weights")
customWVol        = input.float(0.5, "Volume Weight", minval = 0.0, maxval = 3.0, step = 0.1, group = "Override â€” Weights")
customWCycle      = input.float(1.0, "Cycle/Special Weight", minval = 0.0, maxval = 3.0, step = 0.1, group = "Override â€” Weights")

// Quantitative Controls
useRegime         = input.bool(true, "Market Regime Detection", group = "Quant Overlays")
regimeLookback    = input.int(50, "Regime Detection Period", minval = 20, maxval = 100, group = "Quant Overlays")
useVolCluster     = input.bool(true, "Volatility Clustering (GARCH)", group = "Quant Overlays")
volClusterPeriod  = input.int(20, "Vol Clustering Period", minval = 10, maxval = 50, group = "Quant Overlays")
useHurst          = input.bool(true, "Hurst Exponent Analysis", group = "Quant Overlays")
hurstLookback     = input.int(100, "Hurst Lookback", minval = 50, maxval = 200, group = "Quant Overlays")
useDrawdownCtrl   = input.bool(true, "Drawdown Control", group = "Quant Overlays")
maxDrawdownPct    = input.float(12.0, "Max Drawdown %", minval = 5.0, maxval = 30.0, group = "Quant Overlays")
eliteThreshMultInput = input.float(1.5, "ğŸ’ Elite Threshold Multiplier (base)", minval = 1.1, maxval = 2.0, step = 0.1, group = "Quant Overlays")
eliteThreshMult = useCustom ? eliteThreshMultInput : sensEliteMult

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Â§ 3 â€” AUTO-PARAMETER RESOLUTION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
rsiLen     = useCustom ? customRsiLen     : (isCrypto ? 21  : 14)
rsiOB      = useCustom ? customRsiOB      : (isCrypto ? 80  : (isMining ? 75 : 70))
rsiOS      = useCustom ? customRsiOS      : (isCrypto ? 25  : (isMining ? 30 : 35))
macdFast   = useCustom ? customMacdFast   : (isCrypto ? 17  : 12)
macdSlow   = useCustom ? customMacdSlow   : (isCrypto ? 21  : 26)
macdSig    = useCustom ? customMacdSig    : (isCrypto ? 15  : 9)
rocLen     = useCustom ? customRocLen     : 14
emaFast    = useCustom ? customEmaFast    : (isMining ? 10  : 20)
emaSlow    = useCustom ? customEmaSlow    : (isMining ? 30  : 50)
adxLen     = useCustom ? customAdxLen     : (isCrypto ? 13  : 14)
adxThresh  = useCustom ? customAdxThresh  : (isMining ? 15  : 20)
bbLen      = useCustom ? customBbLen      : 20
bbStd      = useCustom ? customBbStd      : (isCrypto ? 2.5 : (isMining ? 2.0 : 1.8))
stochLen   = useCustom ? customStochLen   : 14
volLen     = useCustom ? customVolLen     : 20
volSpike   = useCustom ? customVolSpike   : (isCrypto ? 2.0 : (isMining ? 3.0 : 1.5))
baseCooldown   = useCustom ? customCooldown   : (isCrypto ? 12  : (isMining ? 12 : 10))
baseBuyThresh  = useCustom ? customBuyThresh  : (isCrypto ? 8   : (isMining ? 7  : 7))
baseSellThresh = useCustom ? customSellThresh : (isCrypto ? -7  : (isMining ? -6 : -6))

// Apply sensitivity scaling
cooldown   = math.max(2, math.round(baseCooldown * sensCooldownMult))
buyThresh  = math.max(2, math.round(baseBuyThresh * sensThreshMult))
sellThresh = math.min(-2, math.round(baseSellThresh * sensThreshMult))

wMom       = useCustom ? customWMom       : (isMining ? 0.8 : 1.0)
wTrend     = useCustom ? customWTrend     : (isMining ? 1.0 : 1.5)
wMeanRev   = useCustom ? customWMeanRev   : (isCrypto ? 0.8 : (isMining ? 1.0 : 0.9))
wVol       = useCustom ? customWVol       : (isMining ? 1.2 : 0.5)
wCycle     = useCustom ? customWCycle     : (isETF    ? 0.5 : 1.0)

kcMult     = isCrypto ? 1.5 : (isMining ? 1.3 : 1.5)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Â§ 4 â€” CORE INDICATOR CALCULATIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// --- RSI ---
rsiVal = ta.rsi(close, rsiLen)

// --- Fisher Transform on RSI ---
rsiNorm   = math.max(-0.999, math.min(0.999, (rsiVal - 50) / 50))
fisherRSI = 0.5 * math.log((1 + rsiNorm) / math.max(1 - rsiNorm, 0.001))
fisherPrev = nz(fisherRSI[1])
fisherCrossUp   = ta.crossover(fisherRSI, fisherPrev)
fisherCrossDown = ta.crossunder(fisherRSI, fisherPrev)
fisherExtremeLow  = fisherRSI < -1.5
fisherExtremeHigh = fisherRSI > 1.5

// --- MACD ---
[macdLine, signalLine, macdHist] = ta.macd(close, macdFast, macdSlow, macdSig)

// --- ROC ---
rocVal = ta.roc(close, rocLen)

// --- EMAs ---
emaFastVal = ta.ema(close, emaFast)
emaSlowVal = ta.ema(close, emaSlow)

// --- ADX ---
[diPlus, diMinus, adxVal] = ta.dmi(adxLen, adxLen)

// --- ATR ---
atrVal = ta.atr(14)

// --- Bollinger Bands ---
bbBasis = ta.sma(close, bbLen)
bbDev   = bbStd * ta.stdev(close, bbLen)
bbUpper = bbBasis + bbDev
bbLower = bbBasis - bbDev

// --- Keltner Channels ---
kcBasis = ta.sma(close, bbLen)
kcRange = ta.atr(bbLen)
kcUpper = kcBasis + kcRange * kcMult
kcLower = kcBasis - kcRange * kcMult

// --- TTM Squeeze ---
// sqzCount via barssince(not sqzOn) gives consecutive bars IN squeeze;
// sqzDuration[1] on the release bar = how long the squeeze lasted
sqzOn  = bbLower > kcLower and bbUpper < kcUpper
sqzOff = bbLower < kcLower and bbUpper > kcUpper
sqzCount = ta.barssince(not sqzOn)
sqzDuration = nz(sqzCount, 0)
squeezeRelease = sqzOn[1] and sqzOff and sqzDuration[1] >= 3

bbWidth  = bbUpper - bbLower
kcWidth  = kcUpper - kcLower
squeezeRatio = nz(kcWidth, 1) > 0.0001 ? nz(bbWidth) / nz(kcWidth, 1) : 1.0
sqzMaxCompression = squeezeRatio < 0.5

sqzHighest = ta.highest(high, bbLen)
sqzLowest  = ta.lowest(low, bbLen)
sqzAvg1    = math.avg(sqzHighest, sqzLowest)
sqzAvg2    = ta.sma(close, bbLen)
sqzMom     = ta.linreg(close - math.avg(sqzAvg1, sqzAvg2), bbLen, 0)

// --- Stochastic RSI ---
stochRsiK = ta.stoch(rsiVal, rsiVal, rsiVal, stochLen)

// --- Volume ---
volSMA      = ta.sma(volume, volLen)
volSMA_safe = nz(volSMA, 1)
volRatio    = volume / math.max(volSMA_safe, 1)
volSMA50    = ta.sma(volume, 50)
volSMA10    = ta.sma(volume, 10)
volDrought  = isMining and nz(volSMA10) < 0.5 * nz(volSMA50)

// --- OBV ---
obvVal    = ta.obv
obvSMA20  = ta.sma(obvVal, 20)
obvHigh20 = ta.highest(obvVal, 20)
obvLow20  = ta.lowest(obvVal, 20)

// --- Accumulation/Distribution ---
adVal    = ta.accdist
adHigh20 = ta.highest(adVal, 20)
adLow20  = ta.lowest(adVal, 20)

// --- VWMA ---
vwmaVal = ta.vwma(close, 20)

// --- Amihud Illiquidity Ratio ---
dollarVol     = close * math.max(volume, 1)
absReturn     = math.abs(close / math.max(close[1], 0.0001) - 1)
amihudRaw     = absReturn / math.max(dollarVol, 1)
amihudRatio   = ta.sma(amihudRaw, 20)
amihudMA50    = ta.sma(amihudRaw, 50)
amihudRelative = nz(amihudMA50, 1) > 0 ? nz(amihudRatio) / nz(amihudMA50, 1) : 1.0
amihudIlliquid = amihudRelative > 1.5
amihudLiquid   = amihudRelative < 0.7

// --- 200-Week MA ---
ma200w = request.security(syminfo.tickerid, "W", ta.sma(close, 200))

// --- 200-Day SMA ---
sma200d = ta.sma(close, 200)

// --- Pi Cycle ---
dma111   = ta.sma(close, 111)
dma350   = ta.sma(close, 350)
dma350x2 = dma350 * 2

// --- 50-Week EMA ---
ema50w = request.security(syminfo.tickerid, "W", ta.ema(close, 50))

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Â§ 5 â€” QUANTUM EDGE: INSTITUTIONAL QUANT OVERLAYS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// ---- 5a: Market Regime Detection ----
priceSlope = ta.linreg(close, regimeLookback, 0) / math.max(close, 0.0001) * 10000
slopeMA    = ta.sma(priceSlope, 10)
slopeStd   = ta.stdev(priceSlope, regimeLookback)
slopeStdSafe = math.max(nz(slopeStd, 1.0), 0.001)

regimeBull     = useRegime ? (nz(slopeMA) > slopeStdSafe * 0.5) : false
regimeBear     = useRegime ? (nz(slopeMA) < -slopeStdSafe * 0.5) : false
regimeSideways = useRegime ? (math.abs(nz(slopeMA)) <= slopeStdSafe * 0.5) : false

// ---- 5b: Volatility Clustering (GARCH-like) ----
logReturns  = math.log(close / math.max(close[1], 0.0001))
realizedVol = ta.stdev(logReturns, volClusterPeriod) * math.sqrt(252) * 100
volMA       = ta.sma(realizedVol, volClusterPeriod)
volClustRatio = nz(volMA, 1.0) > 0 ? nz(realizedVol, 1.0) / nz(volMA, 1.0) : 1.0

volClusterOK = useVolCluster ? (volClustRatio > 0.5 and volClustRatio < 2.0) : true
volSpikeGarch = volClustRatio > 2.0
volCrush      = volClustRatio < 0.5

// ---- 5c: Hurst Exponent ----
var float hurstExponent = 0.5
var float[] hurstReturns = array.new<float>()

if bar_index >= hurstLookback and useHurst
    if array.size(hurstReturns) >= hurstLookback
        array.shift(hurstReturns)
    array.push(hurstReturns, logReturns)

    if array.size(hurstReturns) >= hurstLookback
        meanRet = 0.0
        for i = 0 to array.size(hurstReturns) - 1
            meanRet := meanRet + array.get(hurstReturns, i)
        meanRet := meanRet / array.size(hurstReturns)

        cumDev = 0.0
        maxDev = 0.0
        minDev = 0.0
        sdSum  = 0.0
        for i = 0 to array.size(hurstReturns) - 1
            ret = array.get(hurstReturns, i)
            cumDev := cumDev + (ret - meanRet)
            maxDev := math.max(maxDev, cumDev)
            minDev := math.min(minDev, cumDev)
            sdSum  := sdSum + math.pow(ret - meanRet, 2)

        rangeVal = maxDev - minDev
        sdVal    = math.sqrt(sdSum / array.size(hurstReturns))

        if sdVal > 0.0001 and rangeVal > 0.0001
            rsRatio = rangeVal / sdVal
            if rsRatio > 0.1 and rsRatio < 100.0
                logRS = math.log(rsRatio)
                logN  = math.log(hurstLookback)
                if logN > 0.0001
                    hurstExponent := math.max(0.1, math.min(0.9, logRS / logN))

hurstTrending      = useHurst ? (hurstExponent > 0.55) : true
hurstMeanReverting = useHurst ? (hurstExponent < 0.45) : false

// ---- 5d: Drawdown Control (equity-based) ----
var float peakEquity = strategy.initial_capital
var float currentDD  = 0.0

currentEquity = strategy.equity
if currentEquity > peakEquity
    peakEquity := currentEquity
    currentDD  := 0.0
else
    currentDD := (peakEquity - currentEquity) / peakEquity * 100

drawdownOK = useDrawdownCtrl ? currentDD < maxDrawdownPct : true

// ---- 5e: Liquidity Proxy ----
spreadProxy   = (high - low) / math.max(close, 0.0001) * 100
spreadMA      = ta.sma(spreadProxy, 20)
liquidityGood = nz(spreadProxy) < nz(spreadMA) * 1.2
liquidityPoor = nz(spreadProxy) > nz(spreadMA) * 1.8

// ---- 5f: Multi-Period Momentum Quality ----
mom5   = ta.roc(close, 5)
mom10  = ta.roc(close, 10)
mom20  = ta.roc(close, 20)
mom50  = ta.roc(close, 50)
momQuality = (nz(mom5) > 0 ? 1.0 : -1.0) * 0.4 +
             (nz(mom10) > 0 ? 1.0 : -1.0) * 0.3 +
             (nz(mom20) > 0 ? 1.0 : -1.0) * 0.2 +
             (nz(mom50) > 0 ? 1.0 : -1.0) * 0.1
strongMomQuality = momQuality > 0.3
weakMomQuality   = momQuality < -0.3

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Â§ 5g â€” REGIME-CONDITIONAL DYNAMIC THRESHOLDS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
volRegimeAdj = math.max(0.8, math.min(1.2, volClustRatio))

dynRsiOB = math.round(50 + (rsiOB - 50) * volRegimeAdj)
dynRsiOS = math.round(50 - (50 - rsiOS) * volRegimeAdj)

dynAdxThresh = math.round(adxThresh * (2.0 - volRegimeAdj))

dynBuyThresh  = math.round(buyThresh * volRegimeAdj)
dynSellThresh = math.round(sellThresh * volRegimeAdj)
dynEliteBuy   = math.round(dynBuyThresh * eliteThreshMult)
dynEliteSell  = math.round(dynSellThresh * eliteThreshMult)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Â§ 6 â€” FACTOR SCORING (10 Factors)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// ---- Factor 1: RSI Momentum + Fisher Transform ----
rsiCrossAboveOS = ta.crossover(rsiVal, dynRsiOS)
rsiCrossBelowOB = ta.crossunder(rsiVal, dynRsiOB)
rsiRising       = rsiVal > rsiVal[1]
rsiFalling      = rsiVal < rsiVal[1]

f1_rsi = 0.0
if fisherExtremeLow and rsiCrossAboveOS
    f1_rsi := 3.0
else if rsiCrossAboveOS or (fisherExtremeLow and fisherCrossUp)
    f1_rsi := 2.0
else if rsiVal < 50 and rsiVal > dynRsiOS and rsiRising
    f1_rsi := 1.0
else if rsiVal >= 40 and rsiVal <= 60
    f1_rsi := 0.0
else if rsiVal > 50 and rsiVal < dynRsiOB and rsiFalling
    f1_rsi := -1.0
else if rsiCrossBelowOB or (fisherExtremeHigh and fisherCrossDown)
    f1_rsi := -2.0
else if fisherExtremeHigh and rsiCrossBelowOB
    f1_rsi := -3.0

if isCrypto and timeframe.isweekly and rsiVal < 30
    if rsiRising
        f1_rsi := fisherExtremeLow ? 3.0 : 2.0
    else
        f1_rsi := math.max(f1_rsi, 1.0)

// ---- Factor 2: MACD Momentum ----
macdHistCrossUp   = ta.crossover(macdHist, 0)
macdHistCrossDown = ta.crossunder(macdHist, 0)
macdBullCross     = ta.crossover(macdLine, signalLine)
macdBearCross     = ta.crossunder(macdLine, signalLine)

f2_macd = 0.0
if macdHistCrossUp
    f2_macd := 2.0
else if macdBullCross
    f2_macd := 1.0
else if macdBearCross
    f2_macd := -1.0
else if macdHistCrossDown
    f2_macd := -2.0

// ---- Factor 3: ROC / Momentum Acceleration ----
rocExtremeThresh = isCrypto ? 10.0 : (isMining ? 15.0 : 4.0)
rocCrossUp   = ta.crossover(rocVal, 0) and nz(rocVal[1]) < -rocExtremeThresh
rocCrossDown = ta.crossunder(rocVal, 0) and nz(rocVal[1]) > rocExtremeThresh

f3_roc = 0.0
if rocCrossUp
    f3_roc := 2.0
else if rocVal > 0 and rocVal > nz(rocVal[1])
    f3_roc := 1.0
else if rocVal < 0 and rocVal < nz(rocVal[1])
    f3_roc := -1.0
else if rocCrossDown
    f3_roc := -2.0

// ---- Factor 4: Trend Regime â€” Dual EMA ----
priceAboveFast   = close > emaFastVal
priceBelowFast   = close < emaFastVal
goldenCross      = ta.crossover(emaFastVal, emaSlowVal)
deathCross       = ta.crossunder(emaFastVal, emaSlowVal)
priceReclaimFast = ta.crossover(close, emaFastVal)
priceLoseFast    = ta.crossunder(close, emaFastVal)
bothEmaRising    = emaFastVal > emaFastVal[1] and emaSlowVal > emaSlowVal[1]
bothEmaFalling   = emaFastVal < emaFastVal[1] and emaSlowVal < emaSlowVal[1]

f4_trend = 0.0
if (priceReclaimFast and goldenCross) or (priceReclaimFast and emaFastVal > emaSlowVal and emaFastVal[1] <= emaSlowVal[1])
    f4_trend := 2.0
else if priceAboveFast and close > emaSlowVal and bothEmaRising
    f4_trend := 1.0
else if close > emaSlowVal and close < emaFastVal
    f4_trend := 0.0
else if priceBelowFast and close < emaSlowVal and bothEmaFalling
    f4_trend := -1.0
else if (priceLoseFast and deathCross) or (priceLoseFast and emaFastVal < emaSlowVal and emaFastVal[1] >= emaSlowVal[1])
    f4_trend := -2.0

// ---- Factor 5: ADX Trend Strength ----
adxRising  = adxVal > adxVal[1]
adxFalling = adxVal < adxVal[1] and adxVal > dynAdxThresh

f5_adx = 0.0
if adxVal > dynAdxThresh and adxRising
    f5_adx := diPlus > diMinus ? 1.0 : -1.0
else if adxVal < dynAdxThresh
    f5_adx := 0.0
else if adxFalling
    f5_adx := 0.0

// ---- Factor 6: Bollinger Band Mean Reversion ----
closedInsideFromLower = close[1] <= bbLower[1] and close > bbLower
closedInsideFromUpper = close[1] >= bbUpper[1] and close < bbUpper

f6_bb = 0.0
if closedInsideFromLower or (low[1] <= bbLower[1] and close > bbLower)
    f6_bb := 2.0
else if close < bbBasis and close > bbLower and close > close[1]
    f6_bb := 1.0
else if close > bbBasis and close < bbUpper and close < close[1]
    f6_bb := -1.0
else if closedInsideFromUpper
    f6_bb := -2.0

// ---- Factor 7: Stochastic RSI Confirmation ----
stochCrossUp   = ta.crossover(stochRsiK, 20)
stochCrossDown = ta.crossunder(stochRsiK, 80)

f7_stoch = 0.0
if stochCrossUp
    f7_stoch := 1.0
else if stochCrossDown
    f7_stoch := -1.0

// ---- Factor 8: Volume Confirmation ----
f8_vol = 0.0
if volRatio >= volSpike
    f8_vol := close > close[1] ? 2.0 : -2.0
else if volRatio >= 1.0
    f8_vol := close > close[1] ? 1.0 : -1.0

if isMining and volRatio < 0.5
    f8_vol := -2.0

// ---- Factor 9: Divergence Detection ----
pivotLowPrice20  = ta.lowest(low, 20)
pivotHighPrice20 = ta.highest(high, 20)
rsiLow20  = ta.lowest(rsiVal, 20)
rsiHigh20 = ta.highest(rsiVal, 20)

bullDiv = low <= nz(pivotLowPrice20[5]) and rsiVal > nz(rsiLow20[5]) and rsiVal < 45
bearDiv = high >= nz(pivotHighPrice20[5]) and rsiVal < nz(rsiHigh20[5]) and rsiVal > 55

f9_div = 0.0
if bullDiv
    f9_div := 2.0
else if bearDiv
    f9_div := -2.0

// ---- Factor 10: Asset-Specific Special Indicators ----
f10_special = 0.0

// Pre-calculate crossover at global scope
piCrossOver = ta.crossover(dma111, dma350x2)

if isCrypto
    mayerMult = sma200d > 0 ? close / sma200d : na
    if not na(mayerMult)
        if mayerMult < 0.8
            f10_special := f10_special + 3.0
        else if mayerMult < 1.0
            f10_special := f10_special + 2.0
        else if mayerMult < 1.5
            f10_special := f10_special + 1.0
        else if mayerMult <= 2.4
            f10_special := f10_special + 0.0
        else if mayerMult <= 3.0
            f10_special := f10_special - 2.0
        else
            f10_special := f10_special - 3.0

    if not na(dma111) and not na(dma350x2)
        piProximity = dma350x2 > 0 ? (dma350x2 - dma111) / dma350x2 : na
        if piCrossOver
            f10_special := f10_special - 3.0
        else if not na(piProximity) and piProximity >= 0 and piProximity < 0.05
            f10_special := f10_special - 1.0
        else if not na(piProximity) and piProximity > 0.1
            f10_special := f10_special + 1.0

    if not na(ma200w) and ma200w > 0 and timeframe.isweekly
        distFrom200w = (close - ma200w) / ma200w
        if close <= ma200w
            f10_special := f10_special + 3.0
        else if distFrom200w <= 0.10
            f10_special := f10_special + 2.0

if isMining
    obvAtHigh      = obvVal >= obvHigh20
    obvAtLow       = obvVal <= obvLow20
    priceFlat      = close[5] != 0 ? math.abs(close - close[5]) / close[5] < 0.03 : false
    priceDeclining = close < close[5]
    priceRising    = close > close[5]

    if obvAtHigh and (priceFlat or priceDeclining)
        f10_special := f10_special + 2.0
    else if obvVal > obvSMA20 and priceRising
        f10_special := f10_special + 1.0
    else if obvAtLow and priceRising
        f10_special := f10_special - 2.0
    else if obvVal < obvSMA20 and priceDeclining
        f10_special := f10_special - 1.0

    if adVal >= adHigh20
        f10_special := f10_special + 1.0
    else if adVal <= adLow20
        f10_special := f10_special - 1.0

    vwmaCrossUp   = ta.crossover(close, vwmaVal) and volRatio > 1.0
    vwmaCrossDown = ta.crossunder(close, vwmaVal) and volRatio > 1.0
    if vwmaCrossUp
        f10_special := f10_special + 1.0
    else if vwmaCrossDown
        f10_special := f10_special - 1.0

    if amihudLiquid and priceRising
        f10_special := f10_special + 1.0
    else if amihudIlliquid and priceDeclining
        f10_special := f10_special - 1.0

if isETF
    if not na(ma200w) and ma200w > 0
        dist200w_etf = (close - ma200w) / ma200w
        if close <= ma200w
            f10_special := f10_special + 3.0
        else if dist200w_etf <= 0.05
            f10_special := f10_special + 2.0

    if not na(ema50w) and ema50w > 0
        dist50w = (close - ema50w) / ema50w
        if dist50w > 0.25
            f10_special := f10_special - 2.0
        else if dist50w > 0.15
            f10_special := f10_special - 1.0
        else if dist50w < -0.20
            f10_special := f10_special + 2.0
        else if dist50w < -0.10
            f10_special := f10_special + 1.0

    if timeframe.isweekly
        body      = math.abs(close - open)
        lowerWick = math.min(open, close) - low
        upperWick = high - math.max(open, close)
        isHammer  = lowerWick > 2 * body and close > emaFastVal * 0.97 and close < emaFastVal * 1.03
        isStar    = upperWick > 2 * body and close > bbUpper * 0.97
        if isHammer
            f10_special := f10_special + 1.0
        else if isStar
            f10_special := f10_special - 1.0

f10_cap = isCrypto ? 4.0 : (isMining ? 3.0 : 3.0)
f10_special := math.max(-f10_cap, math.min(f10_cap, f10_special))

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Â§ 7 â€” COMPOSITE SCORE CALCULATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
sqzEnergyBonus = 0.0
if squeezeRatio < 1.0
    sqzIntensity = (1.0 - math.max(squeezeRatio, 0.3)) / 0.7
    if nz(sqzMom) > 0
        sqzEnergyBonus := sqzIntensity * 1.5
    else if nz(sqzMom) < 0
        sqzEnergyBonus := -sqzIntensity * 1.5

sqzReleaseBonus = 0.0
if squeezeRelease
    bullFactorCount = (f1_rsi > 0 ? 1 : 0) + (f2_macd > 0 ? 1 : 0) + (f4_trend > 0 ? 1 : 0) + (f6_bb > 0 ? 1 : 0)
    bearFactorCount = (f1_rsi < 0 ? 1 : 0) + (f2_macd < 0 ? 1 : 0) + (f4_trend < 0 ? 1 : 0) + (f6_bb < 0 ? 1 : 0)
    if nz(sqzMom) > 0 and bullFactorCount >= 3
        sqzReleaseBonus := 2.0
    else if nz(sqzMom) < 0 and bearFactorCount >= 3
        sqzReleaseBonus := -2.0

compositeScore = (f1_rsi * wMom) + (f2_macd * wMom) + (f3_roc * wMom) +
                 (f4_trend * wTrend) + (f5_adx * wTrend) +
                 (f6_bb * wMeanRev) + (f7_stoch * wMeanRev) +
                 (f8_vol * wVol) +
                 (f9_div * wMom) +
                 (f10_special * wCycle) +
                 sqzEnergyBonus + sqzReleaseBonus

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Â§ 8 â€” SIGNAL GENERATION (Two-Tier: Standard + Elite)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
var int   barsSinceSignal = 999
var int   lastSignalDir   = 0
var int   signalCountYear = 0
var int   lastSignalBar   = 0
var float lastBuyScore    = na
var float lastSellScore   = na

barsSinceSignal := barsSinceSignal + 1

cooldownMet = barsSinceSignal >= cooldown
canBuy      = (lastSignalDir != 1)
canSell     = (lastSignalDir != -1)

lowLiquidityFlag = isMining and volDrought
mayerMultCurrent = isCrypto and sma200d > 0 ? close / sma200d : na
suppressBuy      = isCrypto and not na(mayerMultCurrent) and mayerMultCurrent > 3.0
suppressSell     = isCrypto and not na(mayerMultCurrent) and mayerMultCurrent < 0.7

// Standard signals
buySignal  = compositeScore >= dynBuyThresh and cooldownMet and canBuy and not lowLiquidityFlag and not suppressBuy
sellSignal = compositeScore <= dynSellThresh and cooldownMet and canSell and not lowLiquidityFlag and not suppressSell

// Elite signal gates
amihudGateOK = isMining ? (not amihudIlliquid) : true

eliteGateBuy = (not regimeBear or not useRegime) and (volClusterOK or not useVolCluster) and (hurstTrending or not useHurst) and (drawdownOK or not useDrawdownCtrl) and (liquidityGood) and (strongMomQuality) and (amihudGateOK)

eliteGateSell = (not regimeBull or not useRegime) and (volClusterOK or not useVolCluster) and (hurstTrending or not useHurst) and (drawdownOK or not useDrawdownCtrl) and (liquidityGood) and (weakMomQuality) and (amihudGateOK)

// Elite signals
eliteBuy  = compositeScore >= dynEliteBuy and cooldownMet and canBuy and not lowLiquidityFlag and not suppressBuy and eliteGateBuy
eliteSell = compositeScore <= dynEliteSell and cooldownMet and canSell and not lowLiquidityFlag and not suppressSell and eliteGateSell

// Combined signal flags (for strategy execution)
anyBuy  = (eliteBuy or buySignal) and not (eliteSell or sellSignal)
anySell = (eliteSell or sellSignal) and not (eliteBuy or buySignal)

// Update state
if anyBuy
    lastSignalDir   := 1
    barsSinceSignal := 0
    lastSignalBar   := bar_index
    lastBuyScore    := compositeScore
    signalCountYear := signalCountYear + 1

if anySell
    lastSignalDir   := -1
    barsSinceSignal := 0
    lastSignalBar   := bar_index
    lastSellScore   := compositeScore
    signalCountYear := signalCountYear + 1

if year != year[1]
    signalCountYear := 0

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Â§ 9 â€” STRATEGY EXECUTION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
if anyBuy
    strategy.entry("Long", strategy.long)

if anySell
    strategy.close("Long")
    if enableShorts
        strategy.entry("Short", strategy.short)

if anyBuy and enableShorts
    strategy.close("Short")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Â§ 10 â€” FORWARD RETURN TRACKING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Track every signal with price at signal time and forward prices at 4/8/13/26 bars
// Uses arrays capped at 500 signals to avoid memory issues

var int   MAX_SIGNALS = 500

// --- BUY signal tracking arrays ---
var int[]   buyBarArr      = array.new<int>()
var float[] buyPriceArr    = array.new<float>()

// --- SELL signal tracking arrays ---
var int[]   sellBarArr     = array.new<int>()
var float[] sellPriceArr   = array.new<float>()

// --- Forward return accumulators for BUY signals ---
var float buyFwd4Sum   = 0.0
var int   buyFwd4Count = 0
var float buyFwd8Sum   = 0.0
var int   buyFwd8Count = 0
var float buyFwd13Sum  = 0.0
var int   buyFwd13Count = 0
var float buyFwd26Sum  = 0.0
var int   buyFwd26Count = 0
var int   buyCorrectN  = 0
var int   buyTotalN    = 0

// --- Forward return accumulators for SELL signals ---
var float sellFwd4Sum   = 0.0
var int   sellFwd4Count = 0
var float sellFwd8Sum   = 0.0
var int   sellFwd8Count = 0
var float sellFwd13Sum  = 0.0
var int   sellFwd13Count = 0
var float sellFwd26Sum  = 0.0
var int   sellFwd26Count = 0
var int   sellCorrectN  = 0
var int   sellTotalN    = 0

// Record BUY signal
if anyBuy
    if array.size(buyBarArr) >= MAX_SIGNALS
        array.shift(buyBarArr)
        array.shift(buyPriceArr)
    array.push(buyBarArr, bar_index)
    array.push(buyPriceArr, close)

// Record SELL signal
if anySell
    if array.size(sellBarArr) >= MAX_SIGNALS
        array.shift(sellBarArr)
        array.shift(sellPriceArr)
    array.push(sellBarArr, bar_index)
    array.push(sellPriceArr, close)

// Process BUY forward returns â€” only scan from the oldest unprocessed signal onward
// maxLookback is the furthest forward period we track (26, or forwardBars if larger)
var int buyScanStart = 0

maxFwdPeriod = math.max(26, forwardBars)
if array.size(buyBarArr) > 0
    // Advance scan start past signals that are fully processed (older than maxFwdPeriod bars)
    for i = buyScanStart to array.size(buyBarArr) - 1
        if bar_index - array.get(buyBarArr, i) > maxFwdPeriod
            buyScanStart := i + 1
        else
            break

    if buyScanStart < array.size(buyBarArr)
        for i = buyScanStart to array.size(buyBarArr) - 1
            sigBar   = array.get(buyBarArr, i)
            sigPrice = array.get(buyPriceArr, i)
            barsElapsed = bar_index - sigBar

            if barsElapsed == 4
                buyFwd4Sum   := buyFwd4Sum + (close - sigPrice) / sigPrice * 100
                buyFwd4Count := buyFwd4Count + 1

            if barsElapsed == 8
                buyFwd8Sum   := buyFwd8Sum + (close - sigPrice) / sigPrice * 100
                buyFwd8Count := buyFwd8Count + 1

            if barsElapsed == 13
                buyFwd13Sum   := buyFwd13Sum + (close - sigPrice) / sigPrice * 100
                buyFwd13Count := buyFwd13Count + 1

            if barsElapsed == 26
                buyFwd26Sum   := buyFwd26Sum + (close - sigPrice) / sigPrice * 100
                buyFwd26Count := buyFwd26Count + 1

            if barsElapsed == forwardBars
                buyTotalN := buyTotalN + 1
                if close > sigPrice
                    buyCorrectN := buyCorrectN + 1

// Process SELL forward returns â€” only scan from the oldest unprocessed signal onward
var int sellScanStart = 0

if array.size(sellBarArr) > 0
    for i = sellScanStart to array.size(sellBarArr) - 1
        if bar_index - array.get(sellBarArr, i) > maxFwdPeriod
            sellScanStart := i + 1
        else
            break

    if sellScanStart < array.size(sellBarArr)
        for i = sellScanStart to array.size(sellBarArr) - 1
            sigBar   = array.get(sellBarArr, i)
            sigPrice = array.get(sellPriceArr, i)
            barsElapsed = bar_index - sigBar

            if barsElapsed == 4
                sellFwd4Sum   := sellFwd4Sum + (close - sigPrice) / sigPrice * 100
                sellFwd4Count := sellFwd4Count + 1

            if barsElapsed == 8
                sellFwd8Sum   := sellFwd8Sum + (close - sigPrice) / sigPrice * 100
                sellFwd8Count := sellFwd8Count + 1

            if barsElapsed == 13
                sellFwd13Sum   := sellFwd13Sum + (close - sigPrice) / sigPrice * 100
                sellFwd13Count := sellFwd13Count + 1

            if barsElapsed == 26
                sellFwd26Sum   := sellFwd26Sum + (close - sigPrice) / sigPrice * 100
                sellFwd26Count := sellFwd26Count + 1

            if barsElapsed == forwardBars
                sellTotalN := sellTotalN + 1
                if close < sigPrice
                    sellCorrectN := sellCorrectN + 1

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Â§ 11 â€” BACKTEST STATS TABLE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
if barstate.islast
    // ---- Compute strategy performance metrics ----
    totalTrades   = strategy.closedtrades
    grossProfit   = strategy.grossprofit
    grossLoss     = math.abs(strategy.grossloss)
    profitFactor  = grossLoss > 0 ? grossProfit / grossLoss : (grossProfit > 0 ? 999.0 : 0.0)

    // Win/loss counting
    wins   = 0
    losses = 0
    winPctSum  = 0.0
    lossPctSum = 0.0

    if totalTrades > 0
        for i = 0 to totalTrades - 1
            tradePnl = strategy.closedtrades.profit(i)
            tradeEntry = strategy.closedtrades.entry_price(i)
            if tradeEntry > 0
                tradePct = tradePnl / tradeEntry * 100
                if tradePnl >= 0
                    wins := wins + 1
                    winPctSum := winPctSum + tradePct
                else
                    losses := losses + 1
                    lossPctSum := lossPctSum + tradePct

    winRate    = totalTrades > 0 ? wins * 100.0 / totalTrades : 0.0
    avgWinPct  = wins > 0 ? winPctSum / wins : 0.0
    avgLossPct = losses > 0 ? lossPctSum / losses : 0.0

    // Max drawdown from strategy
    maxDD = strategy.max_drawdown

    // Forward return averages
    buyAvg4   = buyFwd4Count > 0 ? buyFwd4Sum / buyFwd4Count : na
    buyAvg8   = buyFwd8Count > 0 ? buyFwd8Sum / buyFwd8Count : na
    buyAvg13  = buyFwd13Count > 0 ? buyFwd13Sum / buyFwd13Count : na
    buyAvg26  = buyFwd26Count > 0 ? buyFwd26Sum / buyFwd26Count : na

    sellAvg4  = sellFwd4Count > 0 ? sellFwd4Sum / sellFwd4Count : na
    sellAvg8  = sellFwd8Count > 0 ? sellFwd8Sum / sellFwd8Count : na
    sellAvg13 = sellFwd13Count > 0 ? sellFwd13Sum / sellFwd13Count : na
    sellAvg26 = sellFwd26Count > 0 ? sellFwd26Sum / sellFwd26Count : na

    buyHitRate  = buyTotalN > 0 ? buyCorrectN * 100.0 / buyTotalN : na
    sellHitRate = sellTotalN > 0 ? sellCorrectN * 100.0 / sellTotalN : na

    // ---- Build table ----
    var table stats = table.new(position.bottom_right, 3, 24,
                                bgcolor = color.new(#0D1117, 5),
                                border_width = 1,
                                border_color = color.new(#30363D, 0))

    headerBg = color.new(#161B22, 0)
    headerFg = color.new(#58A6FF, 0)
    labelFg  = color.new(#8B949E, 0)
    valueFg  = color.new(#C9D1D9, 0)
    greenFg  = color.new(#3FB950, 0)
    redFg    = color.new(#F85149, 0)
    yellowFg = color.new(#D29922, 0)
    dimFg    = color.new(#484F58, 0)

    row = 0

    // === HEADER: STRATEGY PERFORMANCE ===
    table.cell(stats, 0, row, "STRATEGY PERFORMANCE", text_color = headerFg, text_size = size.small, bgcolor = headerBg)
    table.cell(stats, 1, row, "", bgcolor = headerBg)
    table.cell(stats, 2, row, "", bgcolor = headerBg)
    table.merge_cells(stats, 0, row, 2, row)
    row := row + 1

    // Total Trades
    table.cell(stats, 0, row, "Total Trades", text_color = labelFg, text_size = size.tiny)
    table.cell(stats, 1, row, str.tostring(totalTrades), text_color = valueFg, text_size = size.tiny)
    table.cell(stats, 2, row, str.tostring(wins) + "W / " + str.tostring(losses) + "L", text_color = dimFg, text_size = size.tiny)
    row := row + 1

    // Win Rate
    wrColor = winRate >= 50 ? greenFg : redFg
    table.cell(stats, 0, row, "Win Rate", text_color = labelFg, text_size = size.tiny)
    table.cell(stats, 1, row, str.tostring(winRate, "#.1") + "%", text_color = wrColor, text_size = size.tiny)
    table.cell(stats, 2, row, "", text_size = size.tiny)
    row := row + 1

    // Profit Factor
    pfColor = profitFactor >= 1.5 ? greenFg : (profitFactor >= 1.0 ? yellowFg : redFg)
    table.cell(stats, 0, row, "Profit Factor", text_color = labelFg, text_size = size.tiny)
    table.cell(stats, 1, row, profitFactor >= 100 ? ">99" : str.tostring(profitFactor, "#.##"), text_color = pfColor, text_size = size.tiny)
    table.cell(stats, 2, row, "", text_size = size.tiny)
    row := row + 1

    // Avg Win %
    table.cell(stats, 0, row, "Avg Win %", text_color = labelFg, text_size = size.tiny)
    table.cell(stats, 1, row, str.tostring(avgWinPct, "#.##") + "%", text_color = greenFg, text_size = size.tiny)
    table.cell(stats, 2, row, "", text_size = size.tiny)
    row := row + 1

    // Avg Loss %
    table.cell(stats, 0, row, "Avg Loss %", text_color = labelFg, text_size = size.tiny)
    table.cell(stats, 1, row, str.tostring(avgLossPct, "#.##") + "%", text_color = redFg, text_size = size.tiny)
    table.cell(stats, 2, row, "", text_size = size.tiny)
    row := row + 1

    // Max Drawdown
    table.cell(stats, 0, row, "Max Drawdown", text_color = labelFg, text_size = size.tiny)
    table.cell(stats, 1, row, str.tostring(maxDD, "#.##"), text_color = redFg, text_size = size.tiny)
    table.cell(stats, 2, row, "(currency)", text_color = dimFg, text_size = size.tiny)
    row := row + 1

    // Net Profit
    netPnl = strategy.netprofit
    netColor = netPnl >= 0 ? greenFg : redFg
    table.cell(stats, 0, row, "Net Profit", text_color = labelFg, text_size = size.tiny)
    table.cell(stats, 1, row, str.tostring(netPnl, "#.##"), text_color = netColor, text_size = size.tiny)
    netPct = strategy.initial_capital > 0 ? netPnl / strategy.initial_capital * 100 : 0.0
    table.cell(stats, 2, row, str.tostring(netPct, "#.#") + "%", text_color = netColor, text_size = size.tiny)
    row := row + 1

    // === HEADER: SIGNAL HIT RATE ===
    table.cell(stats, 0, row, "SIGNAL HIT RATE (" + str.tostring(forwardBars) + "-bar)", text_color = headerFg, text_size = size.small, bgcolor = headerBg)
    table.cell(stats, 1, row, "", bgcolor = headerBg)
    table.cell(stats, 2, row, "", bgcolor = headerBg)
    table.merge_cells(stats, 0, row, 2, row)
    row := row + 1

    // Buy Hit Rate
    buyHrColor = not na(buyHitRate) ? (buyHitRate >= 55 ? greenFg : (buyHitRate >= 45 ? yellowFg : redFg)) : dimFg
    table.cell(stats, 0, row, "BUY Hit Rate", text_color = labelFg, text_size = size.tiny)
    table.cell(stats, 1, row, not na(buyHitRate) ? str.tostring(buyHitRate, "#.1") + "%" : "N/A", text_color = buyHrColor, text_size = size.tiny)
    table.cell(stats, 2, row, str.tostring(buyCorrectN) + "/" + str.tostring(buyTotalN), text_color = dimFg, text_size = size.tiny)
    row := row + 1

    // Sell Hit Rate
    sellHrColor = not na(sellHitRate) ? (sellHitRate >= 55 ? greenFg : (sellHitRate >= 45 ? yellowFg : redFg)) : dimFg
    table.cell(stats, 0, row, "SELL Hit Rate", text_color = labelFg, text_size = size.tiny)
    table.cell(stats, 1, row, not na(sellHitRate) ? str.tostring(sellHitRate, "#.1") + "%" : "N/A", text_color = sellHrColor, text_size = size.tiny)
    table.cell(stats, 2, row, str.tostring(sellCorrectN) + "/" + str.tostring(sellTotalN), text_color = dimFg, text_size = size.tiny)
    row := row + 1

    // === HEADER: BUY FORWARD RETURNS ===
    table.cell(stats, 0, row, "BUY FORWARD RETURNS", text_color = headerFg, text_size = size.small, bgcolor = headerBg)
    table.cell(stats, 1, row, "Avg %", text_color = headerFg, text_size = size.small, bgcolor = headerBg)
    table.cell(stats, 2, row, "n", text_color = headerFg, text_size = size.small, bgcolor = headerBg)
    row := row + 1

    // Buy fwd 4
    b4Color = not na(buyAvg4) ? (buyAvg4 > 0 ? greenFg : redFg) : dimFg
    table.cell(stats, 0, row, "  4-bar", text_color = labelFg, text_size = size.tiny)
    table.cell(stats, 1, row, not na(buyAvg4) ? str.tostring(buyAvg4, "#.##") + "%" : "---", text_color = b4Color, text_size = size.tiny)
    table.cell(stats, 2, row, str.tostring(buyFwd4Count), text_color = dimFg, text_size = size.tiny)
    row := row + 1

    // Buy fwd 8
    b8Color = not na(buyAvg8) ? (buyAvg8 > 0 ? greenFg : redFg) : dimFg
    table.cell(stats, 0, row, "  8-bar", text_color = labelFg, text_size = size.tiny)
    table.cell(stats, 1, row, not na(buyAvg8) ? str.tostring(buyAvg8, "#.##") + "%" : "---", text_color = b8Color, text_size = size.tiny)
    table.cell(stats, 2, row, str.tostring(buyFwd8Count), text_color = dimFg, text_size = size.tiny)
    row := row + 1

    // Buy fwd 13
    b13Color = not na(buyAvg13) ? (buyAvg13 > 0 ? greenFg : redFg) : dimFg
    table.cell(stats, 0, row, "  13-bar", text_color = labelFg, text_size = size.tiny)
    table.cell(stats, 1, row, not na(buyAvg13) ? str.tostring(buyAvg13, "#.##") + "%" : "---", text_color = b13Color, text_size = size.tiny)
    table.cell(stats, 2, row, str.tostring(buyFwd13Count), text_color = dimFg, text_size = size.tiny)
    row := row + 1

    // Buy fwd 26
    b26Color = not na(buyAvg26) ? (buyAvg26 > 0 ? greenFg : redFg) : dimFg
    table.cell(stats, 0, row, "  26-bar", text_color = labelFg, text_size = size.tiny)
    table.cell(stats, 1, row, not na(buyAvg26) ? str.tostring(buyAvg26, "#.##") + "%" : "---", text_color = b26Color, text_size = size.tiny)
    table.cell(stats, 2, row, str.tostring(buyFwd26Count), text_color = dimFg, text_size = size.tiny)
    row := row + 1

    // === HEADER: SELL FORWARD RETURNS ===
    table.cell(stats, 0, row, "SELL FORWARD RETURNS", text_color = headerFg, text_size = size.small, bgcolor = headerBg)
    table.cell(stats, 1, row, "Avg %", text_color = headerFg, text_size = size.small, bgcolor = headerBg)
    table.cell(stats, 2, row, "n", text_color = headerFg, text_size = size.small, bgcolor = headerBg)
    row := row + 1

    // Sell fwd 4
    s4Color = not na(sellAvg4) ? (sellAvg4 < 0 ? greenFg : redFg) : dimFg
    table.cell(stats, 0, row, "  4-bar", text_color = labelFg, text_size = size.tiny)
    table.cell(stats, 1, row, not na(sellAvg4) ? str.tostring(sellAvg4, "#.##") + "%" : "---", text_color = s4Color, text_size = size.tiny)
    table.cell(stats, 2, row, str.tostring(sellFwd4Count), text_color = dimFg, text_size = size.tiny)
    row := row + 1

    // Sell fwd 8
    s8Color = not na(sellAvg8) ? (sellAvg8 < 0 ? greenFg : redFg) : dimFg
    table.cell(stats, 0, row, "  8-bar", text_color = labelFg, text_size = size.tiny)
    table.cell(stats, 1, row, not na(sellAvg8) ? str.tostring(sellAvg8, "#.##") + "%" : "---", text_color = s8Color, text_size = size.tiny)
    table.cell(stats, 2, row, str.tostring(sellFwd8Count), text_color = dimFg, text_size = size.tiny)
    row := row + 1

    // Sell fwd 13
    s13Color = not na(sellAvg13) ? (sellAvg13 < 0 ? greenFg : redFg) : dimFg
    table.cell(stats, 0, row, "  13-bar", text_color = labelFg, text_size = size.tiny)
    table.cell(stats, 1, row, not na(sellAvg13) ? str.tostring(sellAvg13, "#.##") + "%" : "---", text_color = s13Color, text_size = size.tiny)
    table.cell(stats, 2, row, str.tostring(sellFwd13Count), text_color = dimFg, text_size = size.tiny)
    row := row + 1

    // Sell fwd 26
    s26Color = not na(sellAvg26) ? (sellAvg26 < 0 ? greenFg : redFg) : dimFg
    table.cell(stats, 0, row, "  26-bar", text_color = labelFg, text_size = size.tiny)
    table.cell(stats, 1, row, not na(sellAvg26) ? str.tostring(sellAvg26, "#.##") + "%" : "---", text_color = s26Color, text_size = size.tiny)
    table.cell(stats, 2, row, str.tostring(sellFwd26Count), text_color = dimFg, text_size = size.tiny)
    row := row + 1

    // === FOOTER: Signal Counts ===
    table.cell(stats, 0, row, "Total BUY signals", text_color = dimFg, text_size = size.tiny)
    table.cell(stats, 1, row, str.tostring(array.size(buyBarArr)), text_color = dimFg, text_size = size.tiny)
    table.cell(stats, 2, row, "", text_size = size.tiny)
    row := row + 1

    table.cell(stats, 0, row, "Total SELL signals", text_color = dimFg, text_size = size.tiny)
    table.cell(stats, 1, row, str.tostring(array.size(sellBarArr)), text_color = dimFg, text_size = size.tiny)
    table.cell(stats, 2, row, "", text_size = size.tiny)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Â§ 12 â€” MINIMAL PLOT MARKERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
plotshape(anyBuy,  title = "Buy Signal",  style = shape.triangleup,   location = location.belowbar, color = color.new(#3FB950, 0), size = size.small)
plotshape(anySell, title = "Sell Signal", style = shape.triangledown, location = location.abovebar, color = color.new(#F85149, 0), size = size.small)
